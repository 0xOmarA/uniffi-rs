// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

{% import "macros.cpp" as cpp %}

#include "mozilla/{{ ci.namespace()|header_name_cpp }}.h"

namespace mozilla {
namespace {{ ci.namespace()|namespace_cpp }} {


{%- for func in ci.iter_function_definitions() %}

{% call cpp::decl_ret_type(func) %} {{ func.name()|fn_name_cpp }}(
  {%- for arg in func.arguments() %}
  {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
  {%- endfor %}
) {
  {%- call cpp::to_ffi_call(func) %}
}
{%- endfor %}

{%- for obj in ci.iter_object_definitions() %}

{{ obj.name()|class_name_cpp }}::{{ obj.name()|class_name_cpp }}(
  int64_t aHandle
) : mHandle(aHandle) {}

{{ obj.name()|class_name_cpp }}::~{{ obj.name()|class_name_cpp }}() {
  RustError err = {0, nullptr};
  {{ obj.ffi_object_free().name() }}(mHandle, &err);
  MOZ_ASSERT(!err.mCode);
}

{%- for cons in obj.constructors() %}

/* static */
already_AddRefed<{{ obj.name()|class_name_cpp }}> {{ obj.name()|class_name_cpp }}::Create(
  {%- for arg in cons.arguments() %}
  {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
  {%- endfor %}
) {
  {%- call cpp::to_ffi_call_head(cons, "err", "handle") %}
  if (err.mCode) {
    MOZ_ASSERT(false);
    return nullptr;
  }
  RefPtr<{{ obj.name()|class_name_cpp }}> result(new {{ obj.name()|class_name_cpp }}(handle));
  return result.forget();
}
{%- endfor %}

{%- for meth in obj.methods() %}

{% call cpp::decl_ret_type(meth) %} {{ obj.name()|class_name_cpp }}::{{ meth.name()|fn_name_cpp }}(
  {%- for arg in meth.arguments() %}
  {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
  {%- endfor %}
) {
  {%- call cpp::to_ffi_call_with_prefix("mHandle", meth) %}
}
{%- endfor %}

{%- endfor %}

}  // namespace {{ ci.namespace()|namespace_cpp }}
}  // namespace mozilla
