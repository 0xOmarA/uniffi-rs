// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

{% import "macros.cpp" as cpp %}

#ifndef mozilla_{{ ci.namespace()|header_name_cpp }}
#define mozilla_{{ ci.namespace()|header_name_cpp }}

#include <functional>

#include "nsStringFwd.h"
#include "nsTArray.h"
#include "nsTStringHasher.h"
#include "prnetdb.h"

#include "mozilla/Casting.h"
#include "mozilla/CheckedInt.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/HashTable.h"
#include "mozilla/Maybe.h"
#include "mozilla/RefCounted.h"
#include "mozilla/RefPtr.h"
#include "mozilla/Span.h"
#include "mozilla/Utf8.h"

{% include "FFIDeclarationsTemplate.h" %}

namespace mozilla {
namespace {{ ci.namespace()|namespace_cpp }} {

{% include "RustBufferHelper.h" %}

/* Enum types. */

{%- for e in ci.iter_enum_definitions() %}

enum class {{ e.name()|class_name_cpp }} : uint32_t {
  {% for variant in e.variants() %}
  {{ variant|enum_variant_cpp }},
  {% endfor %}
  EndGuard_,
};

template <>
struct detail::ViaFfi<{{ e.name()|class_name_cpp }}, uint32_t> {
  [[nodiscard]] static bool Lift(const uint32_t& aLowered, {{ e.name()|class_name_cpp }}& aLifted) {
    switch (aLowered) {
      {% for variant in e.variants() -%}
      case {{ loop.index }}:
        aLifted = {{ e.name()|class_name_cpp }}::{{ variant|enum_variant_cpp }};
        break;
      {% endfor -%}
      default:
        MOZ_ASSERT(false, "Unexpected enum case");
        return false;
    }
    return true;
  }

  [[nodiscard]] static uint32_t Lower(const {{ e.name()|class_name_cpp }}& aLifted) {
    switch (aLifted) {
      {% for variant in e.variants() -%}
      case {{ e.name()|class_name_cpp }}::{{ variant|enum_variant_cpp }}:
        return {{ loop.index }};
      {% endfor -%}
      default:
        MOZ_ASSERT(false, "Unknown raw enum value");
    }
    return 0;
  }
};

template <>
struct detail::Serializable<{{ e.name()|class_name_cpp }}> {
  static CheckedInt<size_t> Size(const {{ e.name()|class_name_cpp }}& aValue) {
    return sizeof(uint32_t);
  }

  [[nodiscard]] static bool ReadFrom(detail::Reader& aReader, {{ e.name()|class_name_cpp }}& aValue) {
    auto rawValue = aReader.ReadUInt32();
    return detail::ViaFfi<{{ e.name()|class_name_cpp }}, uint32_t>::Lift(rawValue, aValue);
  }

  static void WriteInto(detail::Writer& aWriter, const {{ e.name()|class_name_cpp }}& aValue) {
    aWriter.WriteUInt32(detail::ViaFfi<{{ e.name()|class_name_cpp }}, uint32_t>::Lower(aValue));
  }
};

{%- endfor %}

/* Custom errors. */
{%- for e in ci.iter_error_definitions() %}

class {{ e.name()|class_name_cpp }} {
 public:
  enum class Type {
    {% for value in e.values() %}
    {{ value|enum_variant_cpp }},
    {% endfor %}
  };

  {{ e.name()|class_name_cpp }}(Type aType, nsCString&& aMessage)
      : mType(aType), mMessage(std::move(aMessage)) {}

  virtual ~{{ e.name()|class_name_cpp }}() = default;

  {{ e.name()|class_name_cpp }}({{ e.name()|class_name_cpp }}&&) = default;
  {{ e.name()|class_name_cpp }}& operator=({{ e.name()|class_name_cpp }}&&) = default;

  Type Type() const { return mType; }

  void Message(nsACString& aMessage) const { aMessage = mMessage; }

  static Maybe<{{ e.name()|class_name_cpp }}> FromConsuming(RustError& aError) {
    nsAutoCString message;
    if (aError.mMessage) {
      // Consume the error message by copying it into an `nsCString`, then free
      // the Rust string.
      message.Assign(aError.mMessage);
      RustError err = {0, nullptr};
      {{ ci.ffi_string_free().name() }}(aError.mMessage, &err);
      MOZ_ASSERT(!err.mCode);
    }
    switch (aError.mCode) {
      case 0:
        return Nothing();

      {% for value in e.values() %}
      case {{loop.index}}:
        return Some({{ e.name()|class_name_cpp }}(Type::{{value}}, std::move(message)));
      {% endfor %}

      default:
        return Nothing();
    }
  }

 private:
  enum Type mType;
  nsCString mMessage;
};

{%- endfor %}

/* Record types. */

{%- for rec in ci.iter_record_definitions() %}

struct {{ rec.name()|class_name_cpp }} {
  {%- for field in rec.fields() %}
  {{ field.type_()|type_cpp }} {{ field.name()|field_name_cpp }};
  {%- endfor %}
};

template <>
struct detail::Serializable<{{ rec.name()|class_name_cpp }}> {
  static CheckedInt<size_t> Size(const {{ rec.name()|class_name_cpp }}& aValue) {
    CheckedInt<size_t> size;
    {%- for field in rec.fields() %}
    size += detail::Serializable<{{ field.type_()|type_cpp }}>::Size(aValue.{{ field.name()|field_name_cpp }});
    {%- endfor %}
    return size;
  }

  [[nodiscard]] static bool ReadFrom(detail::Reader& aReader, {{ rec.name()|class_name_cpp }}& aValue) {
    {%- for field in rec.fields() %}
    if (!detail::Serializable<{{ field.type_()|type_cpp }}>::ReadFrom(aReader, aValue.{{ field.name()|field_name_cpp }})) {
      return false;
    }
    {%- endfor %}
    return true;
  }

  static void WriteInto(detail::Writer& aWriter, const {{ rec.name()|class_name_cpp }}& aValue) {
    {%- for field in rec.fields() %}
    detail::Serializable<{{ field.type_()|type_cpp }}>::WriteInto(aWriter, aValue.{{ field.name()|field_name_cpp }});
    {%- endfor %}
  }
};

{%- endfor %}

/* Top-level functions. */

{%- for func in ci.iter_function_definitions() %}

{% call cpp::decl_ret_type(func) %} {{ func.name()|fn_name_cpp }}(
  {%- for arg in func.arguments() %}
  {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
  {%- endfor %}
);

{%- endfor %}

/* Objects. */

{%- for obj in ci.iter_object_definitions() %}

class {{ obj.name()|class_name_cpp }} : public RefCounted<{{ obj.name()|class_name_cpp }}> {
 public:
  MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME({{ obj.name()|class_name_cpp }});

  {%- for cons in obj.constructors() %}

  static already_AddRefed<{{ obj.name()|class_name_cpp }}> Create(
    {%- for arg in cons.arguments() %}
    {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
    {%- endfor %}
  );
  {%- endfor %}

  {%- for meth in obj.methods() %}

  {% call cpp::decl_ret_type(meth) %} {{ meth.name()|fn_name_cpp }}(
    {%- for arg in meth.arguments() %}
    {{ arg.type_()|arg_type_cpp }} {{ arg.name() }}{%- if !loop.last %},{% endif %}
    {%- endfor %}
  );
  {%- endfor %}

  virtual ~{{ obj.name()|class_name_cpp }}();

 private:
  {{ obj.name()|class_name_cpp }}(int64_t aHandle);
  int64_t mHandle;
};

{%- endfor %}

}  // namespace {{ ci.namespace()|header_name_cpp }}
}  // namespace mozilla

#endif  // mozilla_{{ ci.namespace()|header_name_cpp }}
