/* This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use anyhow::{bail, Context, Result};
use camino::{Utf8Path, Utf8PathBuf};
use heck::ToSnakeCase;
use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};
use std::process::Command;
use uniffi_testing::UniFFITestHelper;

/// Run Swift tests for a UniFFI test fixture
pub fn run_test(tmp_dir: &str, fixture_name: &str, script_file: &str) -> Result<()> {
    let script_path = Utf8Path::new(".").join(script_file).canonicalize_utf8()?;
    let test_helper = UniFFITestHelper::new(fixture_name).context("UniFFITestHelper::new")?;
    let out_dir = test_helper
        .create_out_dir(tmp_dir, &script_path)
        .context("create_out_dir()")?;
    test_helper
        .copy_cdylibs_to_out_dir(&out_dir)
        .context("copy_fixture_library_to_out_dir()")?;
    let library_name = calc_library_name(&out_dir)?;
    let generated_sources =
        GeneratedSources::new(&test_helper.cdylib_path()?, &out_dir, &test_helper)
            .context("generate_sources()")?;

    // Compile the generated sources together to create the swift module as a .so file
    let bindings_mod = generated_sources.bindings_module_name()?;
    let bindings_filename = format!("{}testmod_{}{}", DLL_PREFIX, bindings_mod, DLL_SUFFIX);
    let mut command = Command::new("swiftc");
    command
        .current_dir(&out_dir)
        .arg("-emit-module")
        .arg("-module-name")
        .arg(&bindings_mod)
        .arg("-o")
        .arg(&bindings_filename)
        .arg("-emit-library")
        .arg("-Xcc")
        .arg(format!(
            "-fmodule-map-file={}",
            generated_sources.module_map
        ))
        .arg(generated_sources.swift_module);
    let status = command
        .spawn()
        .context("Failed to spawn `swiftc` when compiling bindings")?
        .wait()
        .context("Failed to wait for `swiftc` when compiling bindings")?;
    if !status.success() {
        bail!(
            "running `swiftc` to compile bindings failed ({:?})",
            command
        )
    }

    // Run the test script against compiled bindings

    let mut command = Command::new("swift");
    command
        .current_dir(&out_dir)
        .arg("-I")
        .arg(&out_dir)
        .arg("-L")
        .arg(&out_dir)
        .arg(format!("-l{}", &bindings_filename))
        .arg(format!("-l{}", &library_name))
        .arg("-Xcc")
        .arg(format!(
            "-fmodule-map-file={}",
            generated_sources.module_map
        ))
        .arg(&script_path);
    let status = command
        .spawn()
        .context("Failed to spawn `swiftc` when running test script")?
        .wait()
        .context("Failed to wait for `swiftc` when running test script")?;
    if !status.success() {
        bail!("running `swift` to run test script failed ({:?})", command)
    }
    Ok(())
}

// Stores sources generated by `uniffi-bindgen-swift`
struct GeneratedSources {
    swift_module: Utf8PathBuf,
    module_map: Utf8PathBuf,
}

impl GeneratedSources {
    fn new(
        library_path: &Utf8Path,
        out_dir: &Utf8Path,
        test_helper: &UniFFITestHelper,
    ) -> Result<Self> {
        for source in test_helper.get_compile_sources()? {
            crate::generate_bindings(
                &source.udl_path,
                source.config_path.as_deref(),
                vec!["swift"],
                Some(out_dir),
                Some(library_path),
                false,
            )?;
        }
        Ok(GeneratedSources {
            swift_module: glob1(out_dir.join("*.swift"))?,
            module_map: glob1(out_dir.join("*.modulemap"))?,
        })
    }

    pub fn bindings_module_name(&self) -> Result<String> {
        Ok(self
            .swift_module
            .file_name()
            .unwrap()
            .strip_suffix(".swift")
            .context("bindings_module_name()")?
            .to_snake_case())
    }
}

// Get a single path from a globspec
fn glob1(globspec: Utf8PathBuf) -> Result<Utf8PathBuf> {
    let mut paths = glob::glob(globspec.as_str())?;
    let first = paths
        .next()
        .unwrap_or_else(|| panic!("globspec {:?} returned 0 results", &globspec));
    if paths.next().is_some() {
        bail!(format!(
            "globspec {:?} returned multiple results",
            &globspec
        ));
    }
    Ok(Utf8PathBuf::try_from(first?.canonicalize()?)?)
}

fn calc_library_name(out_dir: &Utf8Path) -> Result<String> {
    let library_path = glob1(out_dir.join(format!("{}*{}", DLL_PREFIX, DLL_SUFFIX)))?;
    Ok(library_path
        .file_name()
        .unwrap()
        .strip_prefix(DLL_PREFIX)
        .unwrap()
        .strip_suffix(DLL_SUFFIX)
        .unwrap()
        .to_string())
}
