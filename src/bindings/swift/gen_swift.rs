/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use anyhow::Result;
use askama::Template;

use crate::interface::*;

// Some config options for it the caller wants to customize the generated python.
// Note that this can only be used to control details of the python *that do not affect the underlying component*,
// sine the details of the underlying component are entirely determined by the `ComponentInterface`.
pub struct Config {
    // No config options yet.
}

impl Config {
    pub fn from(_ci: &ComponentInterface) -> Self {
        Config {
            // No config options yet
        }
    }
}

#[derive(Template)]
#[template(
    ext = "h",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#pragma once

#include <stdbool.h>
#include <stdint.h>

typedef struct RustBuffer {
    int64_t len;
    uint8_t *_Nullable data;
} RustBuffer;

{% for func in ci.iter_ffi_function_definitions() -%}
    {%- match func.return_type() -%}{%- when Some with (type_) %}{{ type_|decl_c }}{% when None %}void{% endmatch %} {{ func.name() }}(
      {%- for arg in func.arguments() %}
      {{ arg.name() }}: {{ arg.type_()|decl_c }}{% if loop.last %}{% else %},{% endif %}
      {%- endfor %}
      // TODO: When we implement error handling, there will be a `*_Nonnull out_err` param here.
    );
{% endfor -%}
"#
)]
pub struct BridgingHeader<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> BridgingHeader<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

#[derive(Template)]
#[template(
    ext = "swift",
    escape = "none",
    source = r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

extension RustBuffer {
    init(bytes: [UInt8]) {
        // TODO: This also copies the buffer. Can we write directly into
        // a Rust buffer?
        let rustBuffer = {{ ci.ffi_bytebuffer_alloc().name() }}(Int64(bytes.count))
        let pointer = UnsafeMutableBufferPointer(start: rustBuffer.data, count: Int(rustBuffer.len))
        bytes.copyBytes(to: pointer)
        self.init(len: Int64(pointer.count), data: pointer.baseAddress!)
    }

    // Frees the buffer in place. The buffer must not be used after this is
    // called.
    func deallocate() {
        rustbuffer_free(self)
    }
}

// A helper class to extract a byte stream from a `Data`.

class DataReader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads a fixed-with integer from the current offset, in big-endian order
    // to match the Kotlin bindings.
    func readInt<T: FixedWidthInteger>() -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            fatalError()
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    func hasRemaining() -> Bool {
        return offset < data.count
    }

    @inlinable
    func readUInt8() -> UInt8 {
        readInt()
    }

    @inlinable
    func readUInt32() -> UInt32 {
        readInt()
    }

    @inlinable
    func readUInt64() -> UInt64 {
        readInt()
    }
}

// A helper class to write bytes into a `Data`.

class DataWriter {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        let _ = withUnsafeBytes(of: &value, { bytes.append(contentsOf: $0) })
    }

    @inlinable
    func writeUInt8(_ value: UInt8) {
        writeInt(value)
    }

    @inlinable
    func writeUInt32(_ value: UInt32) {
        writeInt(value)
    }

    @inlinable
    func writeUInt64(_ value: UInt64) {
        writeInt(value)
    }
}

protocol Lowerable {
    func lower(into buf: DataWriter)
}

protocol Liftable {
    static func lift(from buf: DataReader) -> Self
}

func lowerIntoRustBuffer<T: Lowerable>(_ value: T) -> RustBuffer {
    let writer = DataWriter()
    value.lower(into: writer)
    return RustBuffer(bytes: writer.bytes)
}

func liftFromRustBuffer<T: Liftable>(_ buf: RustBuffer) -> T {
    let reader = DataReader(data: Data(rustBuffer: buf))
    let value = T.lift(from: reader)
    if reader.hasRemaining() {
        fatalError()
    }
    buf.deallocate()
    return value
}

extension Bool : Lowerable, Liftable {
    func lower() -> UInt8 {
        return self ? 1 : 0
    }

    func lower(into buf: DataWriter) {
        buf.writeUInt8(self.lower())
    }

    static func lift(_ v: UInt8) -> Bool {
        return v != 0
    }

    static func lift(from buf: DataReader) -> Bool {
        return self.lift(buf.readUInt8())
    }
}

extension UInt8: Lowerable, Liftable {
    func lower() -> UInt8 {
        return self
    }

    func lower(into buf: DataWriter) {
        buf.writeUInt8(self.lower())
    }

    static func lift(_ v: UInt8) -> UInt8 {
        return v
    }

    static func lift(from buf: DataReader) -> UInt8 {
        return self.lift(buf.readUInt8())
    }
}

extension UInt32: Lowerable, Liftable {
    func lower() -> UInt32 {
        return self
    }

    func lower(into buf: DataWriter) {
        buf.writeUInt32(self.lower())
    }

    static func lift(_ v: UInt32) -> UInt32 {
        return v
    }

    static func lift(from buf: DataReader) -> UInt32 {
        return self.lift(buf.readUInt32())
    }
}

extension UInt64: Lowerable, Liftable {
    func lower() -> UInt64 {
        return self
    }

    func lower(into buf: DataWriter) {
        buf.writeUInt64(self.lower())
    }

    static func lift(_ v: UInt64) -> UInt64 {
        return v
    }

    static func lift(from buf: DataReader) -> UInt64 {
        return self.lift(buf.readUInt64())
    }
}

extension Optional: Lowerable where Wrapped: Lowerable {
    func lower() -> RustBuffer {
        lowerIntoRustBuffer(self)
    }

    func lower(into buf: DataWriter) {
        guard let value = self else {
            buf.writeUInt8(0)
            return
        }
        buf.writeUInt8(1)
        value.lower(into: buf)
    }
}

extension Optional: Liftable where Wrapped: Liftable {
    static func lift(_ buf: RustBuffer) -> Self {
        return liftFromRustBuffer(buf)
    }

    static func lift(from buf: DataReader) -> Self {
        switch buf.readUInt8() {
        case 0:
            return nil
        case 1:
            return Wrapped.lift(from: buf)
        default:
            fatalError()
        }
    }
}

// Public interface members begin here.

{% for e in ci.iter_enum_definitions() %}
    public enum {{ e.name() }}: Lowerable, Liftable {
        {% for value in e.values() %}
        case {{ value|decl_enum_variant_swift }}
        {% endfor %}

        static func lift(_ number: UInt8) -> {{ e.name() }} {
          switch number {
          {% for value in e.values() %}
          case {{ loop.index }}: return .{{ value|decl_enum_variant_swift }}
          {% endfor %}
          default: fatalError()
          }
        }

        static func lift(from buf: DataReader) -> {{ e.name() }} {
          return {{ e.name() }}.lift(UInt8.lift(from: buf))
        }

        func lower() -> UInt8 {
          switch self {
          {% for value in e.values() %}
          case .{{ value|decl_enum_variant_swift }} return {{ loop.index }}
          {% endfor %}
          }
        }

        func lower(into buf: DataWriter) {
          self.lower().lower(into: buf)
        }
    }
{%- endfor -%}

{%- for rec in ci.iter_record_definitions() %}
    public struct {{ rec.name() }}: Lowerable, Liftable {
      {%- for field in rec.fields() %}
      let {{ field.name() }}: {{ field.type_()|decl_swift }}
      {%- endfor %}

      static func lift(_ buf: RustBuffer) -> {{ rec.name() }} {
        return liftFromRustBuffer(buf)
      }

      static func lift(from buf: DataReader) -> {{ rec.name() }} {
        return {{ rec.name() }}(
          {%- for field in rec.fields() %}
          {{ "buf"|lift_from_swift(field.type_()) }}{% if loop.last %}{% else %},{% endif %}
          {%- endfor %}
        )
      }

      func lower() -> RustBuffer {
        lowerIntoRustBuffer(self)
      }

      func lower(into buf: DataWriter) {
        {%- for field in rec.fields() %}
        {{ field.name() }}.lower(into: buf)
        {%- endfor %}
      }
    }
{% endfor %}

{% for func in ci.iter_function_definitions() %}

    {%- match func.return_type() -%}
    {%- when Some with (return_type) %}

        public func {{ func.name() }}(
            {%- for arg in func.arguments() %}
                {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        ) -> {{ return_type|decl_swift }} {
            let _retval = {{ func.ffi_func().name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                {%- endfor %}
            )
            return {{ "_retval"|lift_swift(return_type) }}
        }

    {% when None -%}

        public func {{ func.name() }}(
            {%- for arg in func.arguments() %}
                {{ arg.name() }}: {{ arg.type_()|decl_swift }}{% if loop.last %}{% else %},{% endif %}
            {%- endfor %}
        ) {
            {{ func.ffi_func().name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lower_swift(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                {%- endfor %}
            )
        }

    {%- endmatch %}
{% endfor %}
"#
)]
pub struct SwiftWrapper<'config, 'ci> {
    _config: &'config Config,
    ci: &'ci ComponentInterface,
}

impl<'config, 'ci> SwiftWrapper<'config, 'ci> {
    pub fn new(config: &'config Config, ci: &'ci ComponentInterface) -> Self {
        Self {
            _config: config,
            ci,
        }
    }
}

/// Filters for our Askama templates above. These output C (for the bridging
/// header) and Swift (for the actual library) declarations.
mod filters {
    use super::*;
    use std::fmt;

    /// Declares a C type in the bridging header.
    pub fn decl_c(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            // These native types map nicely to the FFI without conversion.
            TypeReference::U32 => "uint32_t".into(),
            TypeReference::U64 => "uint64_t".into(),
            TypeReference::Float => "float".into(),
            TypeReference::Double => "double".into(),
            TypeReference::Bytes => "RustBuffer".into(),
            // Our FFI lowers Booleans into bytes, to work around JNA bugs.
            // We'll lift these up into Booleans on the Swift side.
            TypeReference::Boolean => "uint8_t".into(),
            // These types need conversion, and special handling for lifting/lowering.
            TypeReference::Enum(_) => "uint32_t".into(),
            TypeReference::Record(_) => "RustBuffer".into(),
            TypeReference::Optional(_) => "RustBuffer".into(),
            TypeReference::Object(_) => "uint64_t".into(),
            _ => panic!("[TODO: decl_c({:?})", type_),
        })
    }

    /// Declares a Swift type in the public interface for the library.
    pub fn decl_swift(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::U32 => "UInt32".into(),
            TypeReference::U64 => "UInt64".into(),
            TypeReference::Float => "Float".into(),
            TypeReference::Double => "Double".into(),
            // TypeReference::Bytes => "Data".into(),
            TypeReference::Boolean => "Bool".into(),
            TypeReference::Enum(name) => name.into(),
            TypeReference::Record(name) => name.into(),
            TypeReference::Optional(type_) => format!("{}?", decl_swift(type_)?),
            TypeReference::Object(name) => name.into(),
            _ => panic!("[TODO: decl_swift({:?})", type_),
        })
    }

    /// Lowers a Swift type into a C type. This is used to pass arguments over
    /// the FFI, from Swift to Rust.
    pub fn lower_swift(
        name: &dyn fmt::Display,
        _type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.lower()", name))
    }

    /// ...
    pub fn lift_from_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.lift(from: {})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn lift_swift(
        name: &dyn fmt::Display,
        type_: &TypeReference,
    ) -> Result<String, askama::Error> {
        Ok(format!("{}.lift({})", decl_swift(type_)?, name))
    }

    /// ...
    pub fn decl_enum_variant_swift(name: &str) -> Result<String, askama::Error> {
        use heck::MixedCase;
        Ok(name.to_mixed_case())
    }
}
