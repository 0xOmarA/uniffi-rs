/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::io::prelude::*;
use std::{
    env,
    collections::HashMap,
    convert::TryFrom, convert::TryInto,
    fs::File,
    iter::IntoIterator,
    fmt::Display,
    path::{Path, PathBuf},
};

use anyhow::bail;
use anyhow::Result;
use anyhow::Error;
use askama::Template;

use super::interface::*;

#[derive(Template)]
#[template(ext="rs", escape="none", source=r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

use anyhow::{bail, Result, Error};

#[no_mangle]
pub extern "C" fn {{ ci.ffi_bytebuffer_alloc().name() }}(size: u32) -> ffi_support::ByteBuffer {
    ffi_support::ByteBuffer::new_with_size(size.max(0) as usize)
}

ffi_support::define_bytebuffer_destructor!({{ ci.ffi_bytebuffer_free().name() }});

{% for e in ci.iter_enum_definitions() %}

    enum {{ e.name() }} {
    {%- for value in e.values() %}
        {{ value }} = {{ loop.index -}},
    {%- endfor %}
    }

    unsafe impl uniffi::support::ViaFfi for {{ e.name() }} {
        type Value = u32;
        fn into_ffi_value(self) -> Self::Value {
            self as Self::Value
        }
        fn try_from_ffi_value(v: Self::Value) -> Result<Self> {
            Ok(match v {
                {%- for value in e.values() %}
                {{ loop.index }} => {{ e.name() }}::{{ value }},
                {%- endfor %}
                _ => bail!("Invalid {{ e.name() }} enum value: {}", v),
            })
        }
    }

{% endfor %}

{% for rec in ci.iter_record_definitions() %}
    #[derive(Debug, Clone)]
    pub struct {{ rec.name() }} {
      {%- for field in rec.fields() %}
        pub {{ field.name() }}: {{ field.type_()|decl_rs -}},
      {%- endfor %}
    }

    impl uniffi::support::Lowerable for {{ rec.name() }} {
        fn lower_into<B: uniffi::support::BufMut>(&self, buf: &mut B) {
          {%- for field in rec.fields() %}
            uniffi::support::Lowerable::lower_into(&self.{{ field.name() }}, buf);
          {%- endfor %}
        }
    }

    impl uniffi::support::Liftable for {{ rec.name() }} {
        fn try_lift_from<B: uniffi::support::Buf>(buf: &mut B) -> Result<Self, Error> {
          Ok(Self {
            {%- for field in rec.fields() %}
                {{ field.name() }}: <{{ field.type_()|decl_rs }} as uniffi::support::Liftable>::try_lift_from(buf)?,
            {%- endfor %}
          })
        }
    }

    impl uniffi::support::ViaFfiUsingByteBuffer for {{ rec.name() }} {}
{% endfor %}

{%- for func in ci.iter_function_definitions() %}
    {%- match func.ffi_func().return_type() -%}
    {%- when Some with (return_type) %}

        #[no_mangle]
        pub extern "C" fn {{ func.ffi_func().name() }}(
            {%- for arg in func.ffi_func().arguments() %}
            {{ arg.name() }}: {{ arg.type_()|decl_c }},
            {%- endfor %}
        ) -> {{ return_type|decl_c }} {
            log::debug!("{{ func.ffi_func().name() }}");
            let _retval: {{ return_type|decl_rs }} = {{ func.name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lift_rs(arg.type_()) }},
                {%- endfor %}
            );
            {{ "_retval"|lower_rs(return_type) }}
        }

    {% when None %}

        #[no_mangle]
        pub extern "C" fn {{ func.ffi_func().name() }}(
            {%- for arg in func.ffi_func().arguments() %}
            {{ arg.name() }}: {{ arg.type_()|decl_c }},
            {%- endfor %}
        ) {
            log::debug!("{{ func.ffi_func().name() }}");
            {{ func.name() }}(
                {%- for arg in func.arguments() %}
                {{ arg.name()|lift_rs(arg.type_()) }},
                {%- endfor %}
            );
        }

    {% endmatch %}
{% endfor -%}

{% for obj in ci.iter_object_definitions() %}
 // TODO: object ({{ "{:?}"|format(obj)}})
{% endfor %}
"#)]
pub struct RustScaffolding<'a> {
  ci: &'a ComponentInterface,
}
impl<'a> RustScaffolding<'a> {
    pub fn new(ci: &'a ComponentInterface) -> Self {
        Self { ci }
    }
}



mod filters {
    use std::fmt;
    use super::*;

    pub fn decl_rs(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            // These can be passed directly over the FFI without conversion.
            TypeReference::U32 => "u32".to_string(),
            TypeReference::U64 => "u64".to_string(),
            TypeReference::Float => "f32".to_string(),
            TypeReference::Double => "f64".to_string(),
            TypeReference::Boolean => "u8".to_string(),
            // While these need conversion, and will require special handling below
            // when lifting/lowering.
            TypeReference::String => "&str".to_string(),
            TypeReference::Enum(name) => name.clone(),
            TypeReference::Record(name) => name.clone(),
            TypeReference::Optional(t) => format!("Option<{}>", decl_rs(t)?),
            _ => panic!("[TODO: decl_rs({:?})]", type_),
        })
    }

    pub fn decl_c(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::String => "FfiStr<'_>".to_string(),
            TypeReference::Enum(_) => "u32".to_string(),
            TypeReference::Record(_) => "ffi_support::ByteBuffer".to_string(),
            TypeReference::Optional(_) => "ffi_support::ByteBuffer".to_string(),
            _ => decl_rs(type_)?
        })
    }

    pub fn lower_rs(nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        // By explicitly naming the type here, we help the rust compiler to type-check the user-provided
        // implementations of the functions that we're wrapping (and also to type-check our generated code).
        Ok(format!("<{} as uniffi::support::ViaFfi>::into_ffi_value({})", decl_rs(type_)?, nm))
        // XXX TODO: could we use IntoFfi here, instead of all of this machinery?
        // We'll probably need it when it comes to error handling.
        // I think we need it so the rust compiler can disambiguate things that return as the same type (e.g. bytebuffer).
        /*let nm = nm.to_string();
        Ok(match type_ {
            TypeReference::U32 => nm,
            TypeReference::U64 => nm,
            TypeReference::Float => nm,
            TypeReference::Double => nm,
            TypeReference::Boolean => format!("(if ({}) {{ 1 }} else {{ 0 }})", nm),
            // It's important that we explicitly name the type when using into() here,
            // so that the rust compiler knows what type of thing we're trying to list to
            // (and can thus properly type-check the user-provided function definitions)
            TypeReference::Enum(type_name) => format!("{}::into::<u32>({})", type_name, nm),
            TypeReference::Record(type_name) => format!("{}::into::<ByteBuffer>({})", type_name, nm),
            TypeReference::Optional(t) => format!("{}::into::<ByteBuffer>({})", decl_rs(t)?, nm),
            _ => panic!("[TODO: LOWER_RS {:?}]", type_),
        })*/
    }

    pub fn lift_rs( nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        // By explicitly naming the type here, we help the rust compiler to type-check the user-provided
        // implementations of the functions that we're wrapping (and also to type-check our generated code).
        Ok(format!("<{} as uniffi::support::ViaFfi>::try_from_ffi_value({}).unwrap()", decl_rs(type_)?, nm)) // Error handling later...
        /*Ok(match type_ {
            TypeReference::U32 => nm,
            TypeReference::U64 => nm,
            TypeReference::Float => nm,
            TypeReference::Double => nm,
            // It's important that we explicitly name the type when using try_from() here,
            // so that the rust compiler knows what type of thing we're trying to list to
            // (and can thus properly type-check the user-provided function definitions)
            TypeReference::Enum(type_name) =>
            TypeReference::Record(type_name) => format!("{}::try_from({}).unwrap()", type_name, nm), // Error handling later...
            TypeReference::Optional(_) => format!("{}.try_into().unwrap()", nm), // Error handling later...
            _ => panic!("[TODO: LIFT_RS {:?}]", type_),
        })*/
    }
}

/*
#[derive(Template)]
#[template(ext="rs", escape="none", source=r#"
lazy_static::lazy_static! {
  static ref UNIFFI_HANDLE_MAP_{{ self.struct_name() }}: ConcurrentHandleMap<{{ self.struct_name() }}> = ConcurrentHandleMap::new();
}
// XXX TODO: interpolate name prefix from containing environment.
define_handle_map_deleter!(UNIFFI_HANDLE_MAP_{{ self.struct_name() }}, {{ self.struct_name() }}_free,);

{%- for m in self.members() %}
    {{ m.render().unwrap() }}
{% endfor -%}
"#)]
struct ObjectScaffolding<'a> {
    ci: &'a types::ComponentInterface,
    obj: &'a types::ObjectType,
}
impl<'a> ObjectScaffolding<'a> {
    fn boxed(ci: &'a types::ComponentInterface, obj: &'a types::ObjectType) -> Box<dyn askama::Template + 'a> {
        Box::new(Self { ci, obj })
    }

    fn struct_name(&self) -> &'a str {
        &self.obj.name
    }

    fn members(&self) -> Vec<Box<dyn askama::Template + 'a>> {
        self.obj.members.iter().map(|m|{
            match m {
                types::ObjectTypeMember::Constructor(cons) => ObjectConstructorScaffolding::boxed(self.ci, self.obj, cons),
                types::ObjectTypeMember::Method(meth) => ObjectMethodScaffolding::boxed(self.ci, self.obj, meth),
            }
        }).collect()
    }
}
#[derive(Template)]
#[template(ext="rs", escape="none", source=r#"
#[no_mangle]
pub extern "C" fn {{ self.ffi_name() }}(
  {%- for arg in cons.argument_types %}
    {{ arg.ffi_name() }}: {{ arg.typ.resolve(ci)|type_decl }},
  {%- endfor %}
  err: &mut ExternError,
) -> u64 {
    log::debug!("{{ self.ffi_name() }}");
    UNIFFI_HANDLE_MAP_{{ obj.name }}.insert_with_output(err, || {
        {{ obj.name }}::{{ cons.name }}(
          {%- for arg in cons.argument_types %}
           {{ arg.ffi_name()|type_lift(arg.typ.resolve(ci)) }},
        {%- endfor %}
        )
    })
}
"#)]
struct ObjectConstructorScaffolding<'a> {
    ci: &'a types::ComponentInterface,
    obj: &'a types::ObjectType,
    cons: &'a types::ObjectTypeConstructor,
}

impl<'a> ObjectConstructorScaffolding<'a> {
    fn boxed(ci: &'a types::ComponentInterface, obj: &'a types::ObjectType, cons: &'a types::ObjectTypeConstructor) -> Box<dyn askama::Template + 'a> {
        Box::new(Self { ci, obj, cons })
    }

    fn ffi_name(&self) -> String {
        format!("{}_{}", self.obj.name, self.cons.name)
    }
}

#[derive(Template)]
#[template(ext="rs", escape="none", source=r#"
#[no_mangle]
pub extern "C" fn {{ self.ffi_name() }}(
  handle u64,
  {%- for arg in meth.argument_types %}
    {{ arg.ffi_name() }}: {{ arg.typ.resolve(ci)|type_decl }},
  {%- endfor %}
  err: &mut ExternError,
)
  {%- match meth.return_type -%}
  {%- when Some with (typ) %}
    -> {{ typ.resolve(ci)|type_decl }}
  {% when None -%}
  {%- endmatch %}
{
    log::debug!("{{ self.ffi_name() }}");
    UNIFFI_HANDLE_MAP_{{ obj.name }}.call_with_result_mut(err, handle, |val| {
        let r = val.{{ meth.name }}(
          {%- for arg in meth.argument_types %}
           {{ arg.ffi_name()|type_lift(arg.typ.resolve(ci)) }},
        {%- endfor %}
        );
        {%- match meth.return_type -%}
        {%- when Some with (typ) %}
        {{ "r"|type_lower(typ.resolve(ci)) }}
        {% when None -%}
        r
        {%- endmatch %}
    })
}"#)]
struct ObjectMethodScaffolding<'a> {
    ci: &'a types::ComponentInterface,
    obj: &'a types::ObjectType,
    meth: &'a types::ObjectTypeMethod,
}

impl<'a> ObjectMethodScaffolding<'a> {
    fn boxed(ci: &'a types::ComponentInterface, obj: &'a types::ObjectType, meth: &'a types::ObjectTypeMethod) -> Box<dyn askama::Template + 'a> {
        Box::new(Self {ci, obj, meth })
    }

    fn ffi_name(&self) -> String {
        format!("{}_{}", self.obj.name, self.meth.name)
    }
}

#[derive(Template)]
#[template(ext="rs", escape="none", source=r#"
TODO: RECORD {{ rec.name }}
"#)]
struct RecordScaffolding<'a> {
    ci: &'a types::ComponentInterface,
    rec: &'a types::RecordType,
}

impl<'a> RecordScaffolding<'a> {
    fn boxed(ci: &'a types::ComponentInterface, rec: &'a types::RecordType) -> Box<dyn askama::Template + 'a> {
        Box::new(Self { ci, rec })
    }
}
*/
