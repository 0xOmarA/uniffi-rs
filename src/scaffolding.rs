/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use anyhow::Result;
use askama::Template;

use super::interface::*;

#[derive(Template)]
#[template(
    ext = "rs",
    escape = "none",
    source = r#####"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Everybody gets basic bytebuffer allocation and freeing, since it's needed
// for passing complex types over the FFI.

#[no_mangle]
pub extern "C" fn {{ ci.ffi_bytebuffer_alloc().name() }}(size: u32) -> ffi_support::ByteBuffer {
    ffi_support::ByteBuffer::new_with_size(size.max(0) as usize)
}

ffi_support::define_bytebuffer_destructor!({{ ci.ffi_bytebuffer_free().name() }});

// For each enum declared in the IDL, we assume the caller as provided a corresponding
// rust `enum`. We provide the traits for sending it across the FFI, which will fail to
// compile if the provided struct has a different shape to the one declared in the IDL.
//
// The enum will be sent over the FFI as a u32, with values assigned according to the
// order of items *as declared in the IDL file*. This might be different to the order
// of items as declared in the rust code, but no harm will come from it.

{% for e in ci.iter_enum_definitions() %}
    unsafe impl uniffi::support::ViaFfi for {{ e.name() }} {
        type Value = u32;
        fn into_ffi_value(self) -> Self::Value {
            match self {
                // If the provided enum doesn't match the options defined in the IDL then
                // this match will fail to compile, with a type error to guide the way.
                {%- for value in e.values() %}
                {{ e.name() }}::{{ value }} => {{ loop.index }},
                {%- endfor %}
            }
        }
        fn try_from_ffi_value(v: Self::Value) -> anyhow::Result<Self> {
            Ok(match v {
                {%- for value in e.values() %}
                {{ loop.index }} => {{ e.name() }}::{{ value }},
                {%- endfor %}
                _ => anyhow::bail!("Invalid {{ e.name() }} enum value: {}", v),
            })
        }
    }
{% endfor %}

// For each record declared in the IDL, we assume the caller has provided a corresponding
// rust `struct` with the declared fields. We provide the traits for sending it across the FFI.
// If the caller's struct does not match the shape and types declared in the IDL then the rust
// compiler will complain with a type error.

{% for rec in ci.iter_record_definitions() %}
    impl uniffi::support::Lowerable for {{ rec.name() }} {
        fn lower_into<B: uniffi::support::BufMut>(&self, buf: &mut B) {
            // If the provided struct doesn't match the fields declared in the IDL, then
            // the generated code here will fail to compile with somewhat helpful error.
            {%- for field in rec.fields() %}
            uniffi::support::Lowerable::lower_into(&self.{{ field.name() }}, buf);
            {%- endfor %}
        }
    }

    impl uniffi::support::Liftable for {{ rec.name() }} {
        fn try_lift_from<B: uniffi::support::Buf>(buf: &mut B) -> anyhow::Result<Self> {
          Ok(Self {
            {%- for field in rec.fields() %}
                {{ field.name() }}: <{{ field.type_()|decl_rs }} as uniffi::support::Liftable>::try_lift_from(buf)?,
            {%- endfor %}
          })
        }
    }

    impl uniffi::support::ViaFfiUsingByteBuffer for {{ rec.name() }} {}
{% endfor %}

// For each top-level function declared in the IDL, we assume the caller has provided a corresponding
// rust function of the same name. We provide a `pub extern "C"` wrapper that does type conversions to
// send data across the FFI, which will fail to compile if the provided function does not match what's
// specified in the IDL.

{%- for func in ci.iter_function_definitions() %}
    #[no_mangle]
    pub extern "C" fn {{ func.ffi_func().name() }}(
        {%- for arg in func.ffi_func().arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_c }},
        {%- endfor %}
    ) -> {% match func.ffi_func().return_type() %}{% when Some with (return_type) %}{{ return_type|decl_c }}{% else %}(){% endmatch %} {
        log::debug!("{{ func.ffi_func().name() }}");
        // If the provided function does not match the signature specified in the IDL
        // then this attempt to cal it will not compile, and will give guideance as to why.
        let _retval = {{ func.name() }}(
            {%- for arg in func.arguments() %}
            {{ arg.name()|lift_rs(arg.type_()) }},
            {%- endfor %}
        );
        {% match func.return_type() %}{% when Some with (return_type) %}{{ "_retval"|lower_rs(return_type) }}{% else %}{% endmatch %}
    }
{% endfor -%}

{% for obj in ci.iter_object_definitions() %}

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct`
// with an `impl` for each method on the object. We create a `ConcurrentHandleMap` for safely handing
// out references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the IDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.

lazy_static::lazy_static! {
  static ref UNIFFI_HANDLE_MAP_{{ obj.name()|upper }}: ffi_support::ConcurrentHandleMap<{{ obj.name() }}> = ffi_support::ConcurrentHandleMap::new();
}

// XXX TODO: destructors.
// These will need to be defined as another FFI function on the Object struct, and included automatically
// in the set of all FFI functions for use by the bindings.
// define_handle_map_deleter!(UNIFFI_HANDLE_MAP_{{ obj.name() }}, {{ obj.name() }}_free);

{%- for cons in obj.constructors() %}
    #[no_mangle]
    pub extern "C" fn {{ cons.ffi_func().name() }}(
        {%- for arg in cons.ffi_func().arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_c }},
        {%- endfor %}
    ) -> u64 {
        log::debug!("{{ cons.ffi_func().name() }}");
        let mut err: ffi_support::ExternError = Default::default(); // XXX TODO: error handling!
        // If the constructor does not have the same signature as declared in the IDL, then
        // this attempt to call it will fail with a (somewhat) helpful compiler error.
        let _handle = UNIFFI_HANDLE_MAP_{{ obj.name()|upper }}.insert_with_output(&mut err, || {
            let obj = {{ obj.name() }}::{{ cons.name() }}(
                {%- for arg in cons.arguments() %}
                {{ arg.name()|lift_rs(arg.type_()) }},
                {%- endfor %}
            );
            obj
        });
        _handle
    }
{% endfor %}

{%- for meth in obj.methods() %}
    #[no_mangle]
    pub extern "C" fn {{ meth.ffi_func().name() }}(
        {%- for arg in meth.ffi_func().arguments() %}
        {{ arg.name() }}: {{ arg.type_()|decl_c }},
        {%- endfor %}
    ) -> {% match meth.ffi_func().return_type() %}{% when Some with (return_type) %}{{ return_type|decl_c }}{% else %}(){% endmatch %} {
        log::debug!("{{ meth.ffi_func().name() }}");
        let mut err: ffi_support::ExternError = Default::default(); // XXX TODO: error handling!
        // If the method does not have the same signature as declared in the IDL, then
        // this attempt to call it will fail with a (somewhat) helpful compiler error.
        UNIFFI_HANDLE_MAP_{{ obj.name()|upper }}.call_with_output_mut(&mut err, {{ meth.first_argument().name() }}, |obj| {
            let _retval = {{ obj.name() }}::{{ meth.name() }}(
                obj,
                {%- for arg in meth.arguments() %}
                {{ arg.name()|lift_rs(arg.type_()) }},
                {%- endfor %}
            );
            {% match meth.return_type() %}{% when Some with (return_type) %}{{ "_retval"|lower_rs(return_type) }}{% else %}{% endmatch %}
        })
    }
{% endfor %}

{% endfor %}

// Finally, we embed a serialiation of the ComponentInterface in the resulting object file,
// making it a self-contained bundle from which bindings can be generated for other languages.
// Putting it in a custom section like this is a little trick from wasm-bingen that I quite liked.
{% let ci_data = ci.to_bincode() %}
#[no_mangle]
#[link_section = ".uniffi_interface_definition"]
pub static UNIFFI_INTERFACE_DEFINITION: [u8;{{ ci_data.len() }}] = [{% for c in ci_data.as_slice() %}{{ c }},{% endfor %}];
"#####
)]
pub struct RustScaffolding<'a> {
    ci: &'a ComponentInterface,
}
impl<'a> RustScaffolding<'a> {
    pub fn new(ci: &'a ComponentInterface) -> Self {
        Self { ci }
    }
}

mod filters {
    use super::*;
    use std::fmt;

    pub fn decl_rs(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            // These can be passed directly over the FFI without conversion.
            TypeReference::U32 => "u32".to_string(),
            TypeReference::U64 => "u64".to_string(),
            TypeReference::Float => "f32".to_string(),
            TypeReference::Double => "f64".to_string(),
            TypeReference::Boolean => "u8".to_string(),
            // These types need conversion, and will require special handling below
            // when lifting/lowering.
            TypeReference::String => "&str".to_string(),
            TypeReference::Enum(name) => name.clone(),
            TypeReference::Record(name) => name.clone(),
            TypeReference::Optional(t) => format!("Option<{}>", decl_rs(t)?),
            _ => panic!("[TODO: decl_rs({:?})]", type_),
        })
    }

    pub fn decl_c(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::String => "FfiStr<'_>".to_string(),
            TypeReference::Enum(_) => "u32".to_string(),
            TypeReference::Record(_) => "ffi_support::ByteBuffer".to_string(),
            TypeReference::Optional(_) => "ffi_support::ByteBuffer".to_string(),
            TypeReference::Object(_) => "u64".to_string(),
            _ => decl_rs(type_)?,
        })
    }

    pub fn lower_rs(nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        // By explicitly naming the type here, we help the rust compiler to type-check the user-provided
        // implementations of the functions that we're wrapping (and also to type-check our generated code).
        Ok(format!(
            "<{} as uniffi::support::ViaFfi>::into_ffi_value({})",
            decl_rs(type_)?,
            nm
        ))
    }

    pub fn lift_rs(nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        // By explicitly naming the type here, we help the rust compiler to type-check the user-provided
        // implementations of the functions that we're wrapping (and also to type-check our generated code).
        Ok(format!(
            "<{} as uniffi::support::ViaFfi>::try_from_ffi_value({}).unwrap()",
            decl_rs(type_)?,
            nm
        )) // Error handling later...
    }
}
