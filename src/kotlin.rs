/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::io::prelude::*;
use std::{
    env,
    collections::HashMap,
    convert::TryFrom, convert::TryInto,
    fs::File,
    iter::IntoIterator,
    fmt::Display,
    path::{Path, PathBuf},
};

use anyhow::bail;
use anyhow::Result;
use askama::Template;

use super::interface::*;

pub struct Config {
    pub package_name: String
}

#[derive(Template)]
#[template(ext="kt", escape="none", source=r#"
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

package {{ config.package_name }};

import com.sun.jna.Library
import mozilla.appservices.support.uniffi.loadIndirect
import mozilla.appservices.support.uniffi.RustBuffer
import mozilla.appservices.support.uniffi.serializeForRustSize
import mozilla.appservices.support.uniffi.serializeForRustInto
import mozilla.appservices.support.uniffi.deserializeItemFromRust
import java.nio.ByteBuffer

internal typealias _Handle = Long

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
    companion object {
        internal var INSTANCE: _UniFFILib =
            loadIndirect(componentName = "{{ ci.ffi_library_name() }}")
    }

    {% for func in ci.iter_ffi_function_definitions() -%}
        fun {{ func.name() }}(
        {%- for arg in func.arguments() %}
            {{ arg.name() }}: {{ arg.type_()|decl_c_argument }}{% if loop.last %}{% else %},{% endif %}
        {%- endfor %}
        // TODO: When we implement error handling, there will be an out error param here.
        ) {%- match func.return_type() -%}
        {%- when Some with (type_) %}
            : {{ type_|decl_c_return }}
        {% when None -%}
        {%- endmatch %}
    {% endfor -%}
}

// Public interface members begin here.

{% for e in ci.iter_enum_definitions() %}
    enum class {{ e.name() }} {
        {% for value in e.values() %}
        {{ value }}{% if loop.last %};{% else %},{% endif %}
        {% endfor %}

        companion object {
            internal fun fromOrdinal(n: Int): {{ e.name() }} {
                return when (n) {
                  {% for value in e.values() %}
                  {{ loop.index }} -> {{ value }}
                  {% endfor %}
                  else -> {
                      throw RuntimeException("invalid enum value, something is very wrong!!")
                  }
                }
            }
        }
    }
{%- endfor -%}

{%- for rec in ci.iter_record_definitions() %}
    data class {{ rec.name() }} (
      {%- for field in rec.fields() %}
        val {{ field.name() }}: {{ field.type_()|decl_kt }}{% if loop.last %}{% else %},{% endif %}
      {%- endfor %}
    ) {
      companion object {
          // XXX TODO: put this in a `Record` superclass
          internal fun deserializeFromRust(rbuf: RustBuffer.ByValue): {{ rec.name() }} {
             val buf = rbuf.asByteBuffer()!!
             try {
                val item = {{ rec.name() }}.deserializeItemFromRust(buf)
                if (buf.hasRemaining()) {
                    throw RuntimeException("junk remaining in record buffer, something is very wrong!!")
                }
                return item
            } finally {
                _UniFFILib.INSTANCE.{{ ci.ffi_bytebuffer_free().name() }}(rbuf)
            }
          }
          internal fun deserializeItemFromRust(buf: ByteBuffer): {{ rec.name() }} {
              return {{ rec.name() }}(
                {%- for field in rec.fields() %}
                {{ field.type_()|decl_kt }}.deserializeItemFromRust(buf){% if loop.last %}{% else %},{% endif %}
                {%- endfor %}
              )
          }
      }

      internal fun serializeForRust(): RustBuffer.ByValue {
          val buf = _UniFFILib.INSTANCE.{{ ci.ffi_bytebuffer_alloc().name() }}(this.serializeForRustSize())
          try {
                this.serializeForRustInto(buf.asByteBuffer()!!)
                return buf
          } catch (e: Throwable) {
                _UniFFILib.INSTANCE.{{ ci.ffi_bytebuffer_free().name() }}(buf)
                throw e;
          }
      }

      internal fun serializeForRustSize(): Int {
          return 0 +
            {%- for field in rec.fields() %}
            this.{{ field.name() }}.serializeForRustSize(){% if loop.last %}{% else %} +{% endif %}
            {%- endfor %}
      }

      internal fun serializeForRustInto(buf: ByteBuffer) {
          {%- for field in rec.fields() %}
          this.{{ field.name() }}.serializeForRustInto(buf)
          {%- endfor %}
      }
    }

{% endfor %}

{% for ns in ci.iter_namespace_definitions() %}
    // Namespace: {{ ns.name() }}
    // XXX TODO probably this should be like a package or something, but I'm going for the
    // most direct translation for now - a class with a bunch of static methods.

    class {{ ns.name() }} {
        companion object Members {
            {%- for func in ns.functions() %}
                {%- match func.return_type() -%}
                {%- when Some with (return_type) %}

                    fun {{ func.name() }}(
                        {%- for arg in func.arguments() %}
                            {{ arg.name() }}: {{ arg.type_()|decl_kt }}{% if loop.last %}{% else %},{% endif %}
                        {%- endfor %}
                    ): {{ return_type|decl_kt }} {
                        val _retval = _UniFFILib.INSTANCE.{{ func.ffi_func().name() }}(
                            {%- for arg in func.arguments() %}
                                {{ arg.name()|lower_kt(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                             {%- endfor %}
                        )
                        return {{ "_retval"|lift_kt(return_type) }}
                    }

                {% when None -%}

                    fun {{ func.name() }}(
                        {%- for arg in func.arguments() %}
                            {{ arg.name() }}: {{ arg.type_()|decl_kt }}{% if loop.last %}{% else %},{% endif %}
                        {%- endfor %}
                    ) {
                        UniFFILib.INSTANCE.{{ func.ffi_func().name() }}(
                            {%- for arg in func.arguments() %}
                                {{ arg.name()|lower_kt(arg.type_()) }}{% if loop.last %}{% else %},{% endif %}
                             {%- endfor %}
                        )
                    }

                {%- endmatch %}
            {% endfor -%}
        }
    }
{% endfor %}

{% for obj in ci.iter_object_definitions() %}
 // TODO: record ({{ "{:?}"|format(obj)}})
{% endfor %}
"#)]
pub struct KotlinWrapper<'a> {
    config: Config,
    ci: &'a ComponentInterface,
}
impl<'a> KotlinWrapper<'a> {
    pub fn new(config: Config, ci: &'a ComponentInterface) -> Self {
        Self { config, ci }
    }
}

mod filters {
    use std::fmt;
    use super::*;

    pub fn decl_c_argument(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::Boolean => "Byte".to_string(),
            TypeReference::U64 => "Long".to_string(),
            TypeReference::U32 => "Int".to_string(),
            TypeReference::String => "String".to_string(),
            TypeReference::Bytes => "RustBuffer.ByValue".to_string(),
            TypeReference::Enum(_) => "Int".to_string(),
            TypeReference::Record(_) => "RustBuffer.ByValue".to_string(),
            _ => format!("Unit /* [TODO: decl_c_argument({:?})] */", type_),
        })
    }

    pub fn decl_c_return(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::String => "String".to_string(), // XXX TODO: I think this needs to be a ByteBuffer in return position...
            TypeReference::Record(_) => "RustBuffer.ByValue".to_string(),
            _ => decl_c_argument(type_)?
        })
    }

    pub fn decl_kt(type_: &TypeReference) -> Result<String, askama::Error> {
        Ok(match type_ {
            TypeReference::Enum(name) => name.clone(),
            TypeReference::Record(name) => name.clone(),
            _ => decl_c_argument(type_)?
        })
    }

    pub fn lower_kt(nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        let nm = nm.to_string();
        Ok(match type_ {
            TypeReference::Boolean => format!("(if ({}) {{ 1 }} else {{ 0 }})", nm),
            TypeReference::U64 => nm,
            TypeReference::U32 => nm,
            TypeReference::String => nm,
            TypeReference::Bytes => nm,
            TypeReference::Enum(_) => format!("{}.ordinal", nm),
            TypeReference::Record(_) => format!("{}.serializeForRust()", nm),
            _ => format!("Unit /* [TODO: LOWER_KT {:?}] */", type_),
        })
    }

    pub fn lift_kt( nm: &dyn fmt::Display, type_: &TypeReference) -> Result<String, askama::Error> {
        let nm = nm.to_string();
        Ok(match type_ {
            TypeReference::Boolean => format!("({} != 0)", nm),
            TypeReference::U64 => nm,
            TypeReference::U32 => nm,
            TypeReference::String => nm,
            TypeReference::Enum(type_name) => format!("{}.fromOrdinal({})", type_name, nm),
            TypeReference::Record(type_name) => format!("{}.deserializeFromRust({})", type_name, nm),
            _ => format!("Unit /* [TODO: LIFT_KT {:?}] */", type_),
        })
    }
}